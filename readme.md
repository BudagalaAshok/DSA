DSA Cheat Sheet

`Array Problems`
 
1. `Kadane's Algorithm` --> Calculate the sum by iterating each element in an array until it's negative and update the start and end indexes respectively. If it is negative then reset the current sum=0 and update the start and end position. At the end print the start and end position of an array and maxSum as well
2. `Triplet Sum` --> We can use two pointer technique here and the expression a+b+c=k and first calucate the c using c=k-array element and find the two elements with sum=c by using two pointer technique until p1<p2 and inside check for p1!p2
3. `MinimumWindowSubstring` --> To solve this problem we can use hashing and sliding window technique. First create a map of pattern and find the unique character count.Now start sliding window from left to right of a given string, in this process use hashing for the window elements. If we first found a string with all the characters then now try to shrink the window to find the minimum string and then return the length as well.
4. `SubArraySum Equal to Target` --> To solve this problem we can use hashing and prefix sum. we can calculate the prefix sum by iterating each and every element in the array and then check if the current prefix sum - target is exists in the map that means we found an sub array and putting the prefix sum in to map and the frequency how many times the cummulative sum appears. While calculating count we can count the difference of prefix-target
5. `Merge two sorted arrays in to single sorted arrays with out using extra space` --> Using two pointers one is pointing to the first array last index and another one is pointing to first index of second array and compare the both values if first array value is greater than second array value then swap and decrement first pointer and increment second pointer if any one of the case conditions does not match that means they are proper order.After that just sort the first and second array again.
6. `Print all Permutations of a String` --> Permutations means it needs order and it can be solved by using recursion starting from index 0 of a string and iterate from starting to end of the string and swap the positions while iterating and then again call same function with next index once it is done then just swap to original position for next string.If length==string length then print the string
7. `Rat Maze Problem` --> Problem solved using recursion and backtracking in the board starting from (0,0) and to reach (n-1,m-1).For each and every x and y axis we will check if it safe or not to move by checking the position it is blocked or not.Rat can move either right or down in the board so calling the same function again with right(x+1,y) and down (x,y+1). If we found a dead end then we need to back tracking by undoing the previous path and the try for another path. If we reach to the last cell then we found something store it and move forward.
8. `N Queens Problem` --> Problem can be solved using recursion and backtracking first we will place queen in each colum and then iterate the entire rows where we can place the next queen whenever we are placing the queen we will check if it is safe or not. Here we need to check all the 8 directions but we are placing the queen at the column level so we don't need to check for right side all directions of the queen. So we need to check left(here we are in the same row but col>=0 --> col--) and upper diagonal(row>=0 && col>=0 row--,col--) and lower diagonal(row>n && col>-0 row++,col--) If it is safe then mark the row and col in the board then move to the next column and if it is not an possible solution then backtrack by resetting the marked row and col.
9. `Buy and Sell Stock` --> This has two variations, one is we can buy and sell stock only one time and find the maximum profit. Here the initution is we can buy the stock in the previous days whenever the price is minimum based on that we maintain the what was the min value of that stock in previous days from where you are on that day. Based on that we update the minimum and the profit. The cost we calculate was min of the previous day - current value of the stock.
10. `Buy and Sell Stock -II` --> Here we can buy and sell stock as many times and find the max profit based on that. So to solve this problem we can use the recursion/dp. Here we need the operations either we buy or sell and the stock value. So incase if we want to buy that means we are putting the money so amount was substracting and then move to next index with sell option or if the price is high then we move to next day and amount we spend is 0 and option is buy still and then take the max both of it.Similar case for sell as well, here we are getting the money so add the stock value. if we reach the end of the day then we didn't sell so return 0
11. `Coin Change Problem` --> To solve this problem we can use DP. To find the target using the denominations we have here we can pick the coin or not pick the coin and also we can pick the coin any no of times. if the index==0 and target is not zero then check value%target==0(For example 12 and coin we have 3) then return value/target.Let say if we pick the coin then we are the same index f(index, target-coinValueOfThatIndex)  and not pick f(index-1,target) and whenever we are picking we need to check the current value we are picking it is LTE or equal to target and then return the sum of pick and non_pick.
12. `Merge Overlapping sub intervals` --> To solve this problem we can create an object with start and end and then sort based on start and end or we can use the two 2d array and sort the array and then start iterating from starting interval and push that interval to the answer and then check if there are any overlapping intervals, if it's there include it otherwise push the interval to the answer. This ways we can do using single pass iteration and with brute force we can use two for loops as well.TC was O(nlogn)+0(n)
13. `Combination Sum` --> This problem can be solved using recursion and backtracking and the same item can be picked multiple times and here we use approach as pick or notpick and then if we pick we reduce this item value from target and then move to the next index by adding this value to our answer incase if we didn't find the answer then we need to backtrack by removing the element and another case by not picking the element and move to next index in this case we don't consider the value and base case was target==0 and index==length of array then return the stored answer.
14. `Frog Jump Minimum Engery required to reach last step`--> This Problem can be solved using dp and where we are standing right now we can come from (i-1) or (i-2) step and then we need to take the min of these two steps to calculate the energy and stored. For this we need to iterate the array 1 to n and then calcuate first and second jump(Here we need to take the abs value of difference from current and previous value) and take the min and store it and at the end return dp[n-1] value.
15. `Rain water trapping problem`  -> This can be solved to precompute the left bounds that means what was the max height when we are at the current building on left hand side and similarly for the right side we will find the max and then once we find both lb and rb and then we start iterating the heights and then find the max value of lb and rb from the current position and subtract the current building height and then added to the trapped water list
16. `Product of Array expect itselft` -> This problem is same as rain water trapping problem but here we take two array one is left and another one is right we store the first value as 1 and then start iterating up to now and find the product of previous value(left[i-1] * arr[i-1]) and store left[i] and similarly for the right array as well. Once done we iterate the array and put the lb*rb value in to new result array
17. `Sprial Matrix` --> This problem can be used we can traverse the matrix from right->bottom->left->top and for each operation we use an for loop and maintain four variables to keep track left=0,bottom=n-1,right=m-1,top=0. We iterate while loop left<=right and top<=bottom and print the value while printing the each row we use top,right,bottom,top
18. `Implement Queue using two stacks` -> This problem can be using two stacks first one is used for enqueue operation and second one is dequeue while dequeuing we will check stack2 is empty or not if it is empty then push all the elements to stack2 from stack1 and then return the stack2 top element. If stack1 and stack2 is empty then return empty and size is stack1.size()+stack2.size(), here push and pop operations amortized O(1) complexity
19. `Implement Stack using two queues` -> This problem can be solved using two queues first one is used for push operation (we will add all the elements in to the first queue) and for the pop operation we will check queue1 is empty or not if it is empty return null(always check queue1 for empty) and then push all elements to queue2 expect last element from queue1 and now remove the element and do the role reverse now queue1 becomes q2 and q1 becomes q2, similary for top we retreive the last element and then remove and then role reverse, size is both of the queues. Here push O(1) and pop/top have O(n) time complexity Here why we are doing role reverse after pop/top operations because now queue1 is empty and queue2 is having all the elements so making again queue1 as primary to add the new elements
20. `Min Stack Implementation` --> This problem can be solved by taking an extra stack to maintain the min value if stack is empty and current value less than the top of the min stack then we push to the stack, while popping the element from the main stack we will check if the pop element is equal to the top of the min stack then we will remove from minstack as well. Get min always give the min element in the stack.
21. `Convert Integer to Roman` --> To solve this problem first we need to define all the possible values from the program description and then another string array with the respective roman numbers(Descending to ascending). Now iterate the values array and then compare the given input value is GTE or values array number then reduce the respective value and find respective roman number and append to the answer.
22. `Convert Roman to Integer` --> To solve this problem first create a map with all roman characters and the value and then maintain total and prevValue, now start iterating the given string from right to left and then take the current character value from hashmap and compare with the previous value if it is greater than previous value add to the total otherwise reduce from total at last make currentValue as previous value and then finally print the total
23. `Remove Element from Array which is equal to K` --> To Solve this problem we maintain a seperate index if any value is not equal to the value we need to remove then we need move the current element to the index position in the array.Initialize to 0 and then increment the value whenever it is not equal to the target and then finally return the index(count). This way we can do in single pass iteration.
24. `Remove Duplicates from Sorted Array and return the array` -> Iterate through the array starting from the second element. Compare each element with the previous one. Move unique elements to the front of the array using a separate index j. Return j as the count of unique elements. Whenever we found unique element we move that element to front of array by using j index., We have another variation as well we can allow max two duplicates for the same number, in this case we can maintain the count of how many times it got repeated, if count<=2 then we put the current element to the previous unique element and increment the count of unique element
25. `Majority Element in an array`--> This problem can be solved using Booyer Voter Algorithm. Set first element as current candidate and count is 0 and then Increment count for candidate matches, decrement for mismatches; majority element will survive as the candidate, If count==0 then elect currentCandiate as candidate and finally return the candidate.
26. `Jump Game I` --> This problem can be solved by finding the farthest index we can go from current index by iterating the array(farthestIndex=Math.max(i+arr[i], farthestIndex)). If any one of the case if current i value is greater than farther index then in that case we can't reach the end.
27. `Jump Game II`  --> This problem can be solved by using recursion or dp by passing the index and jumps and we need to find the min jump cost from all minimum possible combinations we have.Instead of finding minimum we can find the next farthest ranges and from that next farthest ranges. In this process each range is an a jump
28. `Find H-Index` --> This problem can be solved first sort the given array and iterate the array from each index find the no of papers remaining by calculating (n-i) this defines our h index. If current h index values greater than or equal to citations[i] current value then return h. If this condition doesn't satisfy then at the end return 0;
29. `Find Longest Substring Length with out repeating characters` --> This problem can be solved using sliding window technique and HashSet or HashMap we can use. we can use two pointers to keep track of our current window like start and end adding unique character to the hashset and find the maxLength by end-start+1. If any duplicate character found remove the character from set and move the start pointer and add again current character to the hashset.
30. `Minimum SubArray Sum` --> This problem also can be solved using sliding window technique if the calculated sum is greater than or equal to the target move the end pointer.If currSum is greater than target then we need to remove the start pointer value from the current sum and then move the start pointer until and unless the condition fail currentSum>=target.
31. `Substring with concatenation of all words` --> Use a sliding window to check each substring of combined word length, validating against a frequency map of words to find matching concatenations.
32. `Longest Consecutive Sequence Length` --> This problem can be solved using hashset for push all the elements in to hashset because searching takes O(1) times and now iterate hashset elements and find that is starting number or not. If it is starting number and then find the sequence count by checking num+1 is present in the hashset. If it is not starting number then skip and it runs 0(n) time
33. `Group Anagrams` --> This problem can be solved using hashmap by taking sorted string as key and respective matching characters are added as values. Iterate each string, sort and check if it there in map or not. If it's not there add it and if it is there add the original unsorted string to the list
34. `Happy Number` -> This Problem can be solved using hashset and if the number!=1 and the calculated number does not contain in hashset then iterate. In this process find the squares of the number and then use it for subsequent calculations
35. `Reverse Nodes in a Group of K elements` -> This problem can be solved first the find the kth node and then store the next node and set the kthnode next as null then reverse that particular piece of linked list and store the kthnode in a seperate node as prevnode and then point again to the store node and then do this process for all the other elements
